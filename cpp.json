{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

	"Default cpp format": {
		"prefix": [
			"snippet"
		],
		"body": [
			"//\tCode written by Aditya ;)   ||  C++ Snippet",
			"#include <bits/stdc++.h>",
			"using namespace std;\n",
			"int main(){",	
			"\t${0:}",
			"\treturn 0;",
			"}\n",
		
		],
		"description": "This is a c++ code snippet",
		
	},

	"snippet for testcases":{
		"prefix": [
			"cpsnippet"
		],
		"body": [
			"/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
			" Code written by Aditya ;)   ||  Codechef/codeforces: @adityaraj5200",
			"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/",
			"//----------HEADER----------",
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"",
			"",
			"//----------MACROS----------",
			"#define fastio                        \\",
			"    ios_base::sync_with_stdio(false);  \\",
			"    cin.tie(NULL);                     \\",
			"    cout.tie(NULL)",
			"#define endl                  \"\\n\"",
			"#define all(u)                u.begin(), u.end()",
			"#define rall(v)               v.rbegin(), v.rend()",
			"#define sortall(u)            sort(all(u))",
			"#define lcm(a,b)              (a*b)/__gcd(a,b)",
			"#define gcd(a,b)              __gcd(a,b)",
			"#define setbits(u)            __builtin_popcount(u)",
			"#define ctz(u)                __builtin_ctz(u)",
			"#define clz(u)                __builtin_clz(u)",
			"#define checkbit(num,i)       (num&(1<<i))  //select the bit of position i of val",
			"#define lowbit(u)             ((u)&((u)^((u)-1))) //get the lowest bit of u",
			"",
			"//----------TYPEDEFS----------",
			"typedef unsigned int                       uint;",
			"typedef long long                          ll;",
			"typedef unsigned long long                 ull;",
			"typedef pair<int, int>                     pii;",
			"typedef pair<long long, long long>         pll;",
			"",
			"//----------DEBUG METHODS----------",
			"void __print(int x) { cerr << x; }",
			"void __print(long x) { cerr << x; }",
			"void __print(long long x) { cerr << x; }",
			"void __print(unsigned x) { cerr << x; }",
			"void __print(unsigned long x) { cerr << x; }",
			"void __print(unsigned long long x) { cerr << x; }",
			"void __print(float x) { cerr << x; }",
			"void __print(double x) { cerr << x; }",
			"void __print(long double x) { cerr << x; }",
			"void __print(char x) { cerr << '\\'' << x << '\\''; }",
			"void __print(const char* x) { cerr << '\"' << x << '\"'; }",
			"void __print(const string& x) { cerr << '\"' << x << '\"'; }",
			"void __print(bool x) { cerr << (x ? \"true\" : \"false\"); }",
			"template<typename T, typename V>",
			"void __print(const pair<T, V>& x) { cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}'; }",
			"template<typename T>",
			"void __print(const T& x) { int f = 0; cerr << '{'; for (auto& i : x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\"; }",
			"void _print() { cerr << \"]\\n\"; }",
			"template <typename T, typename... V>",
			"void _print(T t, V... v) { __print(t); if (sizeof...(v)) cerr << \", \"; _print(v...); }",
			"",
			"#ifndef ONLINE_JUDGE",
			"#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)",
			"#define nline cerr << endl",
			"#else",
			"#define debug(x...)",
			"#define nline",
			"#endif",
			"",
			"//----------CONSTANTS----------",
			"const ll mod = 1000000007;",
			"const ll mod2 = 998244353;",
			"",
			"/*/------------------------------ CODE BEGINS ------------------------------/*/",
			"// Put global variables here",
			"const int N = 2e5 + 5;",
			"",
			"void preprocess(){}",
			"",
			"void testcase(){",
			"    ${0:// Solve here}",
			"}",
			"/*/------------------------------- CODE ENDS -------------------------------/*/",
			"",
			"int main(){",
			"    fastio;",
			"    // cout << setprecision(12) << fixed;",
			"",
			"    preprocess();",
			"",
			"    int num_tc=1;",
			"    ${1:cin>>num_tc;}",
			"    for(int tc=1;tc<=num_tc;tc++){",
			"        // debug(tc);",
			"        testcase();",
			"    }",
			"",
			"    return 0;",
			"}",

		],
		"description": "It writes testcase snippet"
	},
	
	"snippet 2 for testcases":{
		"prefix": [
			"cpsmallsnippet"
		],
		"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;\n",
			
			"typedef long long ll;\n",
			"#define all(v) v.begin(),v.end()",
			"#define rall(v) v.rbegin(),v.rend()\n",

			"void solve(){",
			"\t${0:/*Start writing testcases : */}",
			"}",

			"\nint main(){",
			"\tint tc=1;",
			"\t${1:cin>>tc;}",
			"\twhile(tc--){",
			"\t\tsolve();",
			"\t}\n",
			"\treturn 0;",
			"}",
		],
		"description": "It writes testcase snippet2"
	},
	
	
	"snippet for i loop from a to b":{
		"prefix":["fori"],
		"body":[
			"for(int i=${1:0};i<${2:n};i++){",
			"\t${0:/*code*/}",
			"}",
		],
		"description": "for loop with i variable"
	,},
	
	"snippet for i loop in reverse":{
		"prefix":["forireverse"],
		"body":[
			"for(int i=${1:n-1};i>=${2:0};--i){",
			"\t${0:/*code*/}",
			"}",
		],
		"description": "for loop with i variable"
	,},

	"snippet for ij loop":{
		"prefix":["forij"],
		"body":[
			"for(int i=${1:0};i<${2:n};i++){${3:}",
			"\tfor(int j=${4:0};j<${5:n};j++){",
			"\t\t${0:/*code*/}",
			"\t}\n}\n",
		],
		"description": "for loop with i and j variable"
	,},

	"snippet for ji loop":{
		"prefix":["forji"],
		"body":[
			"for(int j=0;j<${1:m};j++){${2:}",
			"\tfor(int i=0;i<${3:n};i++){",
			"\t\t${0:/*code*/}${4:}",
			"\t}\n}",
		],
		"description": "for loop with i variable"
	,},

	"snippet for loop with 1 indexing":{
		"prefix":["for1n"],
		"body":[
			"for(int i=1;i<=n;i++){",
			"\t${0:/*code*/}",
			"}",
		],
		"description": "for loop with i variable"
	,},
	
	"snippet for j loop":{
		"prefix":["forj"],
		"body":[
			"for(int j=${1:0};j<${2:n};j++){",
			"\t${0:/*code*/}",
			"}",
		],
		"description": "for loop with j variable"
	},

	"snippet for j loop in reverse":{
		"prefix":["forjrev"],
		"body":[
			"for(int j=${1:n-1};j>=${2:0};--j){",
			"\t${0:/*code*/}",
			"}",
		],
		"description": "for loop with i variable"
	,},
	
	"snippet for k loop":{
		"prefix":["fork"],
		"body":[
			"for(int k=${1:0};k<${2:n};k++){",
			"\t${0:/*code*/}",
			"}",
		],
		"description": "for loop with k variable"
	},
	
	"snippet for clock time":{
		"prefix": ["clocktime"],
		"body": [
			"\nclock_t begin = clock();\n",
			"${0:/* here, do your time-consuming job */}\n",
			"clock_t end = clock();",
			"double time_spent = (double)(end - begin) / CLOCKS_PER_SEC;",
			"cout<<\"time_spent = \"<<time_spent<<'s'<<endl;\n"
		],
		"description": "Use it to find execution time"
	},
	
	"snippet for checking prime numbers":{
		"prefix": ["funisPrime"],
		"body": [
			"bool isPrime(int num){",
			"\tif(num==1) return false;",
			"\tif(num==2) return true;",
			"\tif(!(num&1)) return false;",
			"\tfor(int i=3;i*i<=num;i+=2){",
			"\t\tif(num%i==0) return false;",
			"\t}",
			"\treturn true;",
			"}\n"
		],
		"description": "Use it to cheking whether num is prime or not"
	},
	
	
	"snippet for getting factorial of a number":{
		"prefix": ["funfactorial"],
		"body": [
			"ll factorial(ll n){",
			"\tll ans = 1;",
			"\tfor(ll i=2;i<=n;i++)",
			"\t\tans *= i;",
			"\treturn ans;",
			"}"
		],
		"description": "Use it to cheking whether num is prime or not"
	},

	"snippet for declaring array and taking input":{
		"prefix": ["arrin"],
		"body": [
			"int ${1:arr}[${2:n}];",
			"for(int i=0;i<${2:n};i++) ",
			"\tcin>>${1:arr}[i];\n",
		],
		"description": "Use it to declare an array and take input in it"
	},
	
	"snippet for displaying an array":{
		"prefix": ["arrout"],
		"body": [
			"for(int i=0;i<n;i++) ",
			"cout<<${1:arr}[i]<<' ';cout<<endl;\n\n",
		],
		"description": "Use it to display an array"
	},

	"snippet for declaring vector and taking input": {
		"prefix": "vecin",
		"body": [
			"vector<${1:int}> ${2:vec}(${3:n});",
			"for(int i=0;i<${3:n};i++){",
			"\tcin>>${2:vec}[i];\n}",
		],
		"description": "snippet for declaring vector and taking input"
	},

	"snippet for displaying a vector":{
		"prefix": ["vecout"],
		"body": [
			"for(int i=0;i<${1:vec}.size();i++){",
			"\tcout<<${1:vec}[i]<<' ';",
			"}",
			"cout<<endl;"
		],
		"description": "Use it to display a vector"
	},

	"snippet for getting randome variables between specified limits":{
		"prefix": ["getrandom"],
		"body": [
			"template<typename T>",
			"T getrandom(T l,T r){",
			"\treturn rand() % (r-l+1) + l;",
			"}\n"
		],
		"description": "Use it to get random elements"
	},

	"snippet for SortBySecond":{
		"prefix": ["sortBySecond"],
		"body": [
			"bool SortBySecond(const pair<int,int> &a,const pair<int,int> &b){",
			"\tif(a.second == b.second)",
			"\t\treturn a.first<b.first;",
			"\treturn a.second<b.second;",
			"}\n"
		],
		"description": " snippet"
	},

	"Snippet for function to check Perfect Square":{
		"prefix": "funisPerfectSquare",
		"body": [
			"bool isPerfectSquare(int num){",
			"    return((ceil(sqrt(num))*ceil(sqrt(num)) == num));",
			"}\n"
		],
		"description": "Snippet for function to check Perfect Square"
	},

	"Snippet for Custom Comparator function pairs":{
		"prefix": "myComp",
		"body": [
			"bool myComp(const pair<int,int> &a,const pair<int,int> &b){",
			"\tif(a.first == b.first) ",
			"\t\treturn a.second>b.second;\n",
			"\treturn a.first<b.first;",
			"}"
		],
		"description": "Snippet for function to check Perfect Square"
	},

	"Snippet for Prime Sieve":{
		"prefix": "SievePrimeumbers",
		"body": [
			"bool prime[100005];",
			"void sieve(int n){",
			"\tmemset(prime,true,sizeof(prime));",
			"\tprime[1]=false;",
			"\tfor (int p=2;p*p<=n;p++){",
			"\t\tif(prime[p]){",
			"\t\t\tfor(int i=p*p;i<=n;i+=p)",
			"\t\t\t\tprime[i]=false;",
			"\t\t}",
			"\t}",
			"}\n"
		],
		"description": "Snippet for Sieve to check Prime Numbers"
	},

	"snippet for all direction movement":{
		"prefix": ["dxy"],
		"body": [
			"// all 4 & 8- direction move",
			"int dx4[4]={1,0,-1,0};",
			"int dy4[4]={0,1,0,-1};",
			"int dx8[8]={1,1,1,0,0,-1,-1,-1};",
			"int dy8[8]={0,1,-1,1,-1,0,1,-1};"

		],
		"description": "This snippet generates testcases for leetcode"
	},

	"snippet for input output in .txt style" :{
		"prefix": ["txtio"],
		"body": [
			"#ifndef ONLINE_JUDGE",
			"\tfreopen(\"input.txt\", \"r\", stdin);",
			"\tfreopen(\"output.txt\", \"w\", stdout);",
			"\tfreopen(\"debug.txt\", \"w\", stderr);",
			"#endif\n",
			"${0:#ifndef ONLINE_JUDGE\n\tfclose(stdin);//move this line to bottom\n#endif}\n"
		],
		"description": "This snippet generates testcases for leetcode"
	},

	"Snippet function to get the value of nCr": {
		"prefix": "funnCr",
		"body": [
			"ll nCr(ll n,ll r){",
			"    r = min(n,n-r);",
			"    ll numerator = 1, denominator = 1, times = r;",
			"    while(times--){",
			"        numerator *=  n--;",
			"        denominator *= r--;",
			"    }",
			"    return numerator/denominator;",
			"}"
		],
		"description": "Use this function to get the value of nCr"
	},
	
	"Use this function to get the value of nPr": {
		"prefix": "funnPr",
		"body": [
			"template<typename T>",
			"T nPr(T n,T r){",
			"    T ans = 1,times = n-r;",
			"    while(times--)",
			"        ans *= n--;",
			"    return ans;",
			"}\n"
		],
		"description": "Use this function to get the value of nPr"
	},
	
	"Use this function to get the Highest setbit of a number": {
		"prefix": "fungetHighestPowerof2",
		"body": [
			"int getHighestPowerof2(int n){",
			"\tn |= n >> 1;",
			"\tn |= n >> 2;",
			"\tn |= n >> 4;",
			"\tn |= n >> 8;",
			"\tn |= n >> 16;",
			"\tn++;",
			"\treturn (n>>1);",
			"}"
		],
		"description": "Use this function to get the value of nPr"
	},

	"Functions to modular exponentiation and modular multiplicative inverse": {
		"prefix": "funModPowAndInv",
		"body": [
			"ll modpow(ll x, ll n, ll m = mod) {",
			"    if (x == 0 && n == 0)",
			"        return 0; // undefined case",
			"    ",
			"    ll res = 1;",
			"    while (n > 0)",
			"    {",
			"        if (n % 2)",
			"            res = (res * x) % m;",
			"        x = (x * x) % m;",
			"        n /= 2;",
			"    }",
			"    return res;",
			"}",
			"",
			"ll modinv(ll x, ll m = mod) {",
			"    return modpow(x, m - 2, m);",
			"}"
		],
		"description": "Functions to modular exponentiation and modular multiplicative inverse"
	},
	
	"snippet for declaring a vector of integer": {
		"prefix": "vec",
		"body": [
			"vector<${1:int}> ${2:vec} = vector<${1:int}>(${3:n},${4:0});\n"
		],
		"description": "snippet for declaring a vector of integer"
	},

	"snippet for declaring a vector of vector of integer": {
		"prefix": "2dvector",
		"body": [
			"vector<vector<${1:int}>> ${2:vec}(${3:n},vector<${1:int}>(${4:m},${5:0}));\n"
		],
		"description": "snippet for declaring a vector of integer"
	},

	"snippet for declaring debug methods": {
		"prefix": "debugmethods",
		"body": [
			"//----------DEBUG METHODS----------",
			"void __print(int x) { cerr << x; }",
			"void __print(long x) { cerr << x; }",
			"void __print(long long x) { cerr << x; }",
			"void __print(unsigned x) { cerr << x; }",
			"void __print(unsigned long x) { cerr << x; }",
			"void __print(unsigned long long x) { cerr << x; }",
			"void __print(float x) { cerr << x; }",
			"void __print(double x) { cerr << x; }",
			"void __print(long double x) { cerr << x; }",
			"void __print(char x) { cerr << '\\'' << x << '\\''; }",
			"void __print(const char* x) { cerr << '\"' << x << '\"'; }",
			"void __print(const string& x) { cerr << '\"' << x << '\"'; }",
			"void __print(bool x) { cerr << (x ? \"true\" : \"false\"); }",
			"template<typename T, typename V>",
			"void __print(const pair<T, V>& x) { cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}'; }",
			"template<typename T>",
			"void __print(const T& x) { int f = 0; cerr << '{'; for (auto& i : x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\"; }",
			"void _print() { cerr << \"]\\n\"; }",
			"template <typename T, typename... V>",
			"void _print(T t, V... v) { __print(t); if (sizeof...(v)) cerr << \", \"; _print(v...); }",
			"",
			"#ifndef ONLINE_JUDGE",
			"#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)",
			"#define nline cerr << endl",
			"#else",
			"#define debug(x...)",
			"#define nline ",
			"#endif",

		],
		"description": "snippet for declaring debug methods"
	},

	"Use this when pasting Solution class template from leetcode": {
		"prefix": "leetcodesnippet",
		"body": [
			"//\tCode written by Aditya ;)   ||  C++ Snippet",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"${0:// Soltuion class of leetcode will go here}",
			"",
			"int main(){",
			"    Solution solution;",
			"",
			"    return 0;",
			"}",
			""
		],
		"description": "Use this when pasting Solution class template from leetcode"
	},
	
	"snippet for lower_bound": {
		"prefix": "lowerbound",
		"body": [
			"auto it = lower_bound(${1:vec}.begin(),${1:vec}.end(),${2:target});",
			"int pos = it-${1:vec}.begin();",
			"int val = *it!=${1:vec}.end() : *it: -1;",
		],
		"description": "Use this to get the lower bound on a sorted array"
	},

	
	"snippet for upper_bound": {
		"prefix": "upperbound",
		"body": [
			"auto it = upper_bound(${1:vec}.begin(),${1:vec}.end(),${2:target});",
			"int pos = it-${1:vec}.begin();",
			"int val = *it!=${1:vec}.end() : *it: -1;",
		],
		"description": "Use this to get the upper bound on a sorted array"
	},

	"snippet for adjacency list input": {
		"prefix": "graphin",
		"body": [
			"int n,m; cin>>n>>m;",
			"int w; cin>>w;",
			"vector<vector<int>> adj(n+1);",
			"for(int i=0;i<m;i++){",
			"    int u,v;cin>>u>>v;",
			"    adj[u].push_back(v);",
			"    adj[v].push_back(u); // delete this in directed graph",
			"}"
		],
		"description": "Adjacency list input"
	},

	"snippet for DFS recursive": {
		"prefix": "dfs",
		"body": [
			"void dfs(int u,vector<vector<int>>& adj,vector<int>& vis){",
			"    vis[u]=1;",
			"    ${0:/*process node u*/}",
			"    for(int v:adj[u]){",
			"        if(!vis[v]){",
			"            dfs(v,adj,vis);",
			"        }",
			"    }",
			"}"
		],
		"description": "Depth First Search template"
	},

	"snippet for DSU": {
		"prefix": "dsu",
		"body": [
			"struct DSU{",
			"    vector<int> parent,sz;",
			"    DSU(int n){",
			"        parent.resize(n);sz.assign(n,1);",
			"        iota(parent.begin(),parent.end(),0);",
			"    }",
			"    int find(int x){",
			"        if(parent[x]==x) return x;",
			"        return parent[x]=find(parent[x]);",
			"    }",
			"    bool unite(int a,int b){",
			"        a=find(a);b=find(b);",
			"        if(a==b) return false;",
			"        if(sz[a]<sz[b]) swap(a,b);",
			"        parent[b]=a;sz[a]+=sz[b];",
			"        return true;",
			"    }",
			"};"
		],
		"description": "Disjoint Set Union (Union-Find) with path compression and union by size"
	},

	"snippet for min heap": {
		"prefix": "minheap",
		"body": [
			"priority_queue<int,vector<int>,greater<int>> pq;"
		],
		"description": "Min heap declaration"
	},

	"snippet for max heap": {
		"prefix": "maxheap",
		"body": [
			"priority_queue<int> pq;"
		],
		"description": "Max heap declaration"
	},
	
	"snippet for 2D matrix input": {
		"prefix": "matrixin",
		"body": [
			"int n; cin>>n;",
			"int m=n; ${1:cin>>m;}",
			"vector<vector<int>> ${2:mat}(n,vector<int>(m));",
			"for(int i=0;i<n;i++){",
			"    for(int j=0;j<m;j++){",
			"        cin>>${2:mat}[i][j];",
			"    }",
			"}"
		],
		"description": "Matrix input snippet"
	},

	"snippet for printing 2D matrix": {
		"prefix": "matrixout",
		"body": [
			"for(int i=0;i<n;i++){",
			"    for(int j=0;j<m;j++){",
			"        cout<<${1:mat}[i][j]<<' ';",
			"    }",
			"    cout<<endl;",
			"}"
		],
		"description": "Matrix output snippet"
	},

	"snippet for 2D matrix in and out": {
		"prefix": "matrixinout",
		"body": [
			"int n; cin>>n;",
			"int m=n;${1:cin>>m;}",
			"vector<vector<int>> ${2:mat}(n,vector<int>(m));",
			"for(int i=0;i<n;i++){",
			"    for(int j=0;j<m;j++){",
			"        cin>>${2:mat}[i][j];",
			"    }",
			"}",
			"",
			"${0:// Populate the matrix here}",
			"",
			"for(int i=0;i<n;i++){",
			"    for(int j=0;j<m;j++){",
			"        cout<<${2:mat}[i][j]<<' ';",
			"    }",
			"    cout<<endl;",
			"}"
		],
		"description": "Matrix output snippet"
	},

	"snippet for sorting a container": {
		"prefix": "sort",
		"body": [
			"sort(${1:vec}.begin(),${1:vec}.end());",
		],
		"description": "Sorting a container"
	},

	"snippet for sorting a container in reverse": {
		"prefix": "sortreverse",
		"body": [
			"sort(${1:vec}.rbegin(),${1:vec}.rend());",
		],
		"description": "Sorting a container in reverse"
	},

	"read any primitive type": {
		"prefix": "readtype",
		"body": [
			"${1:int} ${2:n}; cin>>${2:n};\n"
		],
		"description": "Sorting a container in reverse"
	},

	"Snippet for reading int": {
		"prefix": "readint",
		"body": [
			"int ${1:n}; cin>>${1:n};\n"
		],
		"description": "Snippet for reading int"
	},

	"Snippet for reading string": {
		"prefix": "readstring",
		"body": [
			"string ${1:s}; cin>>${1:s};\n"
		],
		"description": "Snippet for reading string"
	},

	"Snippet for doing conrainer.begin(), container.end()": {
		"prefix": "all",
		"body": [
			"${1:vec}.begin(),${1:vec}.end()"
		],
		"description": "Snippet for reading string"
	},

	"Snippet for BitwiseTrie": {
		"prefix": "bitwiseTrie",
		"body": [
			"struct TrieNode {",
			"    TrieNode* child[2];",
			"    int cnt; // how many numbers pass through this node",
			"    TrieNode() {",
			"        child[0]=child[1]=nullptr;",
			"        cnt=0;",
			"    }",
			"};",
			"",
			"struct BitwiseTrie {",
			"    TrieNode* root;",
			"    int numBits;",
			"",
			"    BitwiseTrie(int bits = 31){",
			"        root = new TrieNode();",
			"        numBits = bits;",
			"    }",
			"",
			"    void insert(int num) {",
			"        TrieNode* node=root;",
			"        for(int i=numBits;i>=0;i--) {",
			"            int bit=(num>>i)&1;",
			"            if(!node->child[bit]){",
			"                node->child[bit]=new TrieNode();",
			"            }",
			"            node=node->child[bit];",
			"            node->cnt++;",
			"        }",
			"    }",
			"",
			"    void erase(int num) {",
			"        TrieNode* node=root;",
			"        for(int i=numBits;i>=0;i--) {",
			"            int bit=(num>>i)&1;",
			"            node=node->child[bit];",
			"            node->cnt--;",
			"        }",
			"    }",
			"",
			"    int getMaxXor(int num) {",
			"        TrieNode* node=root;",
			"        int ans=0;",
			"        for(int i=numBits;i>=0;i--) {",
			"            int bit=(num>>i)&1;",
			"            int opp=1-bit;",
			"            if(node->child[opp] && node->child[opp]->cnt>0) {",
			"                ans |= (1<<i);",
			"                node=node->child[opp];",
			"            } else {",
			"                node=node->child[bit]; // forced to follow same bit",
			"            }",
			"        }",
			"        return ans;",
			"    }",
			"",
			"    int getMinXor(int num) {",
			"        TrieNode* node=root;",
			"        int ans=0;",
			"        for(int i=numBits;i>=0;i--) {",
			"            int bit=(num>>i)&1;",
			"            if(node->child[bit] && node->child[bit]->cnt>0) {",
			"                node=node->child[bit];",
			"            } else {",
			"                ans|=(1<<i);",
			"                node=node->child[1-bit];",
			"            }",
			"        }",
			"        return ans;",
			"    }",
			"",
			"    bool exists(int num) {",
			"        TrieNode* node=root;",
			"        for(int i=numBits;i>=0;i--) {",
			"            int bit=(num>>i)&1;",
			"            if(!node->child[bit] || node->child[bit]->cnt==0) return false;",
			"            node=node->child[bit];",
			"        }",
			"        return true;",
			"    }",
			"};"
		],
		"description": "Snippet for BitwiseTrie"
	},

	"Snippet for StringTrie": {
		"prefix": "stringTrie",
		"body": [
			"struct TrieNode {",
			"    TrieNode* child[26];",
			"    bool isEnd; // marks if a word ends here",
			"    int cnt;    // how many words pass through this node",
			"    TrieNode() {",
			"        isEnd=false;",
			"        cnt=0;",
			"        for(int i=0;i<26;i++) child[i]=nullptr;",
			"    }",
			"};",
			"",
			"struct StringTrie {",
			"    TrieNode* root;",
			"    StringTrie() {",
			"        root=new TrieNode();",
			"    }",
			"",
			"    void insert(const string& s) {",
			"        TrieNode* node=root;",
			"        for(char c:s) {",
			"            int idx=c-'a';",
			"            if(!node->child[idx]) node->child[idx]=new TrieNode();",
			"            node=node->child[idx];",
			"            node->cnt++;",
			"        }",
			"        node->isEnd=true;",
			"    }",
			"",
			"    bool search(const string& s) {",
			"        TrieNode* node=root;",
			"        for(char c:s) {",
			"            int idx=c-'a';",
			"            if(!node->child[idx]) return false;",
			"            node=node->child[idx];",
			"        }",
			"        return node->isEnd;",
			"    }",
			"",
			"    bool startsWith(const string& prefix) {",
			"        TrieNode* node=root;",
			"        for(char c:prefix) {",
			"            int idx=c-'a';",
			"            if(!node->child[idx]) return false;",
			"            node=node->child[idx];",
			"        }",
			"        return true;",
			"    }",
			"",
			"    void erase(const string& s) {",
			"        if(!search(s)) return; // only erase if exists",
			"        TrieNode* node=root;",
			"        for(char c:s) {",
			"            int idx=c-'a';",
			"            node=node->child[idx];",
			"            node->cnt--;",
			"        }",
			"        node->isEnd=false;",
			"    }",
			"};",
			""
		],
		"description": "Snippet for StringTrie"
	},

	"Snippet for getting ceil value when dividing": {
		"prefix": "ceil",
		"body": [
			"((${1:numerator}+(${2:denominator}-1))/${2:denominator})"
		],
		"description": "Snippet for getting ceil value when dividing"
	},

	"snippet for binary search on sorted array": {
		"prefix": "binsearch",
		"body": [
			"int ${1:binarySearch}(vector<int>& a,int target){",
			"    int l=0,r=a.size()-1;",
			"    while(l<=r){",
			"        int mid=l+(r-l)/2;",
			"        if(a[mid]==target) return mid;",
			"        else if(a[mid]<target) l=mid+1;",
			"        else r=mid-1;",
			"    }",
			"    return -1;",
			"}"
		],
		"description": "Standard Binary Search"
	}







}
